/*
 * Copyright (C) 2022 TU Dresden and UC Berkeley
 * 
 * @author Wonseo Choi
 */

 target TypeScript {
    fast: true
};

// import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor ThroughputReactor(totalMessages:number(10000)) {
    
    preamble {=
        function performComputation(double theta) {
            double sint = sin(theta);
            // volatile to defeat dead code elimination
            volatile double res = sint * sint;
        }
    =}
    
    input inMessage:bool;
            
    reaction(inMessage) {=
        performComputation(37.2);
    =}
}


reactor ThroughputProducer(totalMessages:number(10000), numConsumer:number(60)) {
    
    state sent_messages: number(0);
    
    input start:boolean;
    output outMessage:boolean;
    output finished:boolean;

    logical action send_next_msg;
    
    reaction(start, send_next_msg) -> outMessage, finished {=
        outMessage = true;
        ++sent_messages;
        
        if (sent_messages == totalMessages) {
            // reset state
            sent_messages = 0;
            finished = true;
        }

        actions.send_next_msg.schedule(0, null);
    =}
}

main reactor (numMessagesPerReactor:number(10000), numWorkers:number(60)) {
    logical action end;
    state startTime:time;
    producer = new ThroughputProducer(totalMessages=numMessagesPerReactor, numConsumer=numWorkers);
    worker = new[numWorkers] ThroughputReactor(totalMessages=numMessagesPerReactor);

    reaction (startup) -> producer.start {=
        startTime = util.getCurrentPhysicalTime();
    =}

    reaction (producer.finished) -> end {=
        actions.end.schedule(0, null);
    =}

    reaction (end) {=
        const elapsedTime = util.getCurrentPhysicalTime().subtract(startTime as TimeValue);
        console.log("Elapsed time: " + elapsedTime);
        util.requestStop();
    =}

    (producer.outMessage)+ -> worker.inMessage;
}
