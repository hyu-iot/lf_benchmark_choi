// Code generated by the Lingua Franca compiler from:
// file://Users/wonseo/Workspace/lf_benchmark_choi/Choi/src/LF/Sieve.lf
                
import commandLineArgs from 'command-line-args'
import commandLineUsage from 'command-line-usage'
import {Parameter as __Parameter, Timer as __Timer, Reactor as __Reactor, App as __App} from './core/reactor'
import {Action as __Action, Startup as __Startup} from './core/action'
import {Bank as __Bank} from './core/bank'
import {FederatedApp as __FederatedApp} from './core/federation'
import {InPort as __InPort, OutPort as __OutPort, Port as __Port, WritablePort} from './core/port'
import {InMultiPort as __InMultiPort, OutMultiPort as __OutMultiPort} from './core/multiport'
import {Reaction as __Reaction} from './core/reaction'
import {State as __State} from './core/state'
import {TimeUnit, TimeValue, Tag as __Tag, Origin as __Origin} from './core/time'
import {Args as __Args, Variable as __Variable, Triggers as __Triggers, Present, Read, Write, ReadWrite, MultiReadWrite, Sched} from './core/types'
import {Log} from './core/util'
import {ProcessedCommandLineArgs as __ProcessedCommandLineArgs, CommandLineOptionDefs as __CommandLineOptionDefs, CommandLineUsageDefs as __CommandLineUsageDefs, CommandLineOptionSpec as __CommandLineOptionSpec, unitBasedTimeValueCLAType as __unitBasedTimeValueCLAType, booleanCLAType as __booleanCLAType} from './core/cli'

// Imports for protocol buffers


// ************* App Parameters
let __timeout: TimeValue | undefined = undefined;
let __keepAlive: boolean = false;
let __fast: boolean = true;
let __federationID: string = 'Unidentified Federation'

let __noStart = false; // If set to true, don't start the app.

// ************* Custom Command Line Arguments
let __additionalCommandLineArgs : __CommandLineOptionSpec = [
{
    name: 'numIterations',
    type: Number,
    description: 'Custom argument. Refer to /Users/wonseo/Workspace/lf_benchmark_choi/Choi/src/LF/Sieve.lf for documentation.'
},
{
    name: 'totalNumber',
    type: Number,
    description: 'Custom argument. Refer to /Users/wonseo/Workspace/lf_benchmark_choi/Choi/src/LF/Sieve.lf for documentation.'
},
{
    name: 'primeStart',
    type: Number,
    description: 'Custom argument. Refer to /Users/wonseo/Workspace/lf_benchmark_choi/Choi/src/LF/Sieve.lf for documentation.'
},
{
    name: 'primeNumber',
    type: Number,
    description: 'Custom argument. Refer to /Users/wonseo/Workspace/lf_benchmark_choi/Choi/src/LF/Sieve.lf for documentation.'
},
{
    name: 'period',
    type: __unitBasedTimeValueCLAType,
    typeLabel: "{underline '<duration> <units>'}",
    description: 'Custom argument. Refer to /Users/wonseo/Workspace/lf_benchmark_choi/Choi/src/LF/Sieve.lf for documentation.'
}];
let __customCommandLineArgs = __CommandLineOptionDefs.concat(__additionalCommandLineArgs);
let __customCommandLineUsageDefs = __CommandLineUsageDefs;
type __customCLTypeExtension = {numIterations: number, totalNumber: number, primeStart: number, primeNumber: number, period: TimeValue};
__customCommandLineUsageDefs[1].optionList = __customCommandLineArgs;
const __clUsage = commandLineUsage(__customCommandLineUsageDefs);

// Set App parameters using values from the constructor or command line args.
// Command line args have precedence over values from the constructor
let __processedCLArgs: __ProcessedCommandLineArgs & __customCLTypeExtension;
try {
    __processedCLArgs =  commandLineArgs(__customCommandLineArgs) as __ProcessedCommandLineArgs & __customCLTypeExtension;
} catch (e){
    Log.global.error(__clUsage);
    throw new Error("Command line argument parsing failed with: " + e);
}

// Fast Parameter
if (__processedCLArgs.fast !== undefined) {
    if (__processedCLArgs.fast !== null) {
        __fast = __processedCLArgs.fast;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'fast' command line argument is malformed.");
    }
}

// federationID Parameter
if (__processedCLArgs.id !== undefined) {
    if (__processedCLArgs.id !== null) {
        __federationID = __processedCLArgs.id;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'id (federationID)' command line argument is malformed.");
    }
}

// KeepAlive parameter
if (__processedCLArgs.keepalive !== undefined) {
    if (__processedCLArgs.keepalive !== null) {
        __keepAlive = __processedCLArgs.keepalive;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'keepalive' command line argument is malformed.");
    }
}

// Timeout parameter
if (__processedCLArgs.timeout !== undefined) {
    if (__processedCLArgs.timeout !== null) {
        __timeout = __processedCLArgs.timeout;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'timeout' command line argument is malformed.");
    }
}

// Logging parameter (not a constructor parameter, but a command line option)
if (__processedCLArgs.logging !== undefined) {
    if (__processedCLArgs.logging !== null) {
        Log.global.level = __processedCLArgs.logging;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'logging' command line argument is malformed.");
    }
} else {
    Log.global.level = Log.levels.INFO; // Default from target property.
}

// Help parameter (not a constructor parameter, but a command line option)
// NOTE: this arg has to be checked after logging, because the help mode should
// suppress debug statements from it changes logging
if (__processedCLArgs.help === true) {
    Log.global.error(__clUsage);
    __noStart = true;
    // Don't execute the app if the help flag is given.
}

// Now the logging property has been set to its final value,
// log information about how command line arguments were set,
// but only if not in help mode.

// Runtime command line arguments 
if (__processedCLArgs.fast !== undefined && __processedCLArgs.fast !== null
    && !__noStart) {
    Log.global.info("'fast' property overridden by command line argument.");
}
if (__processedCLArgs.id !== undefined && __processedCLArgs.id !== null
    && !__noStart) {
    Log.global.info("'id (federationID)' property overridden by command line argument.");
}
if (__processedCLArgs.keepalive !== undefined && __processedCLArgs.keepalive !== null
    && !__noStart) {
    Log.global.info("'keepalive' property overridden by command line argument.");
}
if (__processedCLArgs.timeout !== undefined && __processedCLArgs.timeout !== null
    && !__noStart) {
    Log.global.info("'timeout' property overridden by command line argument.");
}
if (__processedCLArgs.logging !== undefined && __processedCLArgs.logging !== null
    && !__noStart) {
     Log.global.info("'logging' property overridden by command line argument.");
}

// Custom command line arguments

if (__processedCLArgs.totalNumber !== undefined && __processedCLArgs.totalNumber !== null
    && !__noStart) {
    Log.global.info("'totalNumber' property overridden by command line argument.");
}

if (__processedCLArgs.period !== undefined && __processedCLArgs.period !== null
    && !__noStart) {
    Log.global.info("'period' property overridden by command line argument.");
}

if (__processedCLArgs.primeStart !== undefined && __processedCLArgs.primeStart !== null
    && !__noStart) {
    Log.global.info("'primeStart' property overridden by command line argument.");
}

if (__processedCLArgs.numIterations !== undefined && __processedCLArgs.numIterations !== null
    && !__noStart) {
    Log.global.info("'numIterations' property overridden by command line argument.");
}

if (__processedCLArgs.primeNumber !== undefined && __processedCLArgs.primeNumber !== null
    && !__noStart) {
    Log.global.info("'primeNumber' property overridden by command line argument.");
}
// Assign custom command line arguments

let __CLtotalNumber: number | undefined = undefined;
if (__processedCLArgs.totalNumber !== undefined) {
    if (__processedCLArgs.totalNumber !== null) {
        __CLtotalNumber = __processedCLArgs.totalNumber;
    } else {
        Log.global.error(__clUsage);
        throw new Error("Custom 'totalNumber' command line argument is malformed.");
    }
}
                

let __CLperiod: TimeValue | undefined = undefined;
if (__processedCLArgs.period !== undefined) {
    if (__processedCLArgs.period !== null) {
        __CLperiod = __processedCLArgs.period;
    } else {
        Log.global.error(__clUsage);
        throw new Error("Custom 'period' command line argument is malformed.");
    }
}
                

let __CLprimeStart: number | undefined = undefined;
if (__processedCLArgs.primeStart !== undefined) {
    if (__processedCLArgs.primeStart !== null) {
        __CLprimeStart = __processedCLArgs.primeStart;
    } else {
        Log.global.error(__clUsage);
        throw new Error("Custom 'primeStart' command line argument is malformed.");
    }
}
                

let __CLnumIterations: number | undefined = undefined;
if (__processedCLArgs.numIterations !== undefined) {
    if (__processedCLArgs.numIterations !== null) {
        __CLnumIterations = __processedCLArgs.numIterations;
    } else {
        Log.global.error(__clUsage);
        throw new Error("Custom 'numIterations' command line argument is malformed.");
    }
}
                

let __CLprimeNumber: number | undefined = undefined;
if (__processedCLArgs.primeNumber !== undefined) {
    if (__processedCLArgs.primeNumber !== null) {
        __CLprimeNumber = __processedCLArgs.primeNumber;
    } else {
        Log.global.error(__clUsage);
        throw new Error("Custom 'primeNumber' command line argument is malformed.");
    }
}
                
// =============== START reactor class Filter


export class Filter extends __Reactor {
            
            
    primeStart: __Parameter<number>;
    primeNumber: __Parameter<number>;
    localPrimes: __State<Array<number>>;
    hasChild: __State<boolean>;
            
    inp: __InPort<number>;
    out: __OutPort<number>;
    constructor (
        parent: __Reactor, 
        primeStart: number = 2, 
        primeNumber: number = 1000
    ) {
        super(parent);
                
                
                
        this.primeStart = new __Parameter(primeStart);
        this.primeNumber = new __Parameter(primeNumber);
        this.localPrimes = new __State([]);
        this.hasChild = new __State(false);
                
        this.inp = new __InPort<number>(this);
        this.out = new __OutPort<number>(this);
                
                
        this.addMutation(
            new __Triggers(this.inp),
            new __Args(this.inp, this.writable(this.out), this.primeStart, this.primeNumber, this.localPrimes, this.hasChild),
            function (this, __inp: Read<number>, __out: WritablePort<number>, __primeStart: __Parameter<number>, __primeNumber: __Parameter<number>, __localPrimes: __State<Array<number>>, __hasChild: __State<boolean>) {
                // =============== START react prologue
                const util = this.util;
                let inp = __inp.get();
                let out = __out.get();
                let primeStart = __primeStart.get();
                let primeNumber = __primeNumber.get();
                let localPrimes = __localPrimes.get();
                let hasChild = __hasChild.get();
                // =============== END react prologue
                try {
                    let div = false;
                    const size = localPrimes.length;
                    const p = inp as number;
                    
                    for (const q of localPrimes) {
                        if (Number.isInteger(p / q)) {
                            div = true;
                            break
                        }
                    }
                    
                    if (!div) {
                        if (size < primeNumber) {
                            localPrimes.push(p);
                            // Print finded prime number if want
                            // console.log("New prime number : " + p);
                        }  else {
                            // Potential prime found.
                            if (!hasChild) {                            
                                let n = new Filter(util.getReactor(), p, primeNumber);
                                //this.start(n)
                                // console.log("CREATING...")
                                // let x = this.create(Filter, [this.getReactor(), p])
                                // console.log("CREATED: " + x._getFullyQualifiedName())
                                // FIXME: weird hack. Maybe just accept writable ports as well?
                                // var port = out;
                                // var port = (out as unknown as WritablePort<number>).getPort()
                                // var port = out.writable().getPort();

                                util.connect(__out.getPort(), n.inp);
                                // FIXME: this updates the dependency graph, but it doesn't redo the topological sort
                                // For a pipeline like this one, it is not necessary, but in general it is.
                                // Can we avoid redoing the entire sort?
                                hasChild = true;
                            } else {
                                out = p;
                            }
                        }
                    }
                } finally {
                    // =============== START react epilogue
                    if (out !== undefined) {
                        __out.set(out);
                    }
                    if (localPrimes !== undefined) {
                        __localPrimes.set(localPrimes);
                    }
                    if (hasChild !== undefined) {
                        __hasChild.set(hasChild);
                    }
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class Filter
// =============== START reactor class Ramp


export class Ramp extends __Reactor {
            
            
    totalNumber: __Parameter<number>;
    period: __Parameter<TimeValue>;
            
    next: __Action<number>;
    start: __InPort<boolean>;
    value: __OutPort<number>;
    end: __OutPort<boolean>;
    constructor (
        parent: __Reactor, 
        totalNumber: number = 100000, 
        period: TimeValue = TimeValue.nsec(1)
    ) {
        super(parent);
                
                
                
        this.totalNumber = new __Parameter(totalNumber);
        this.period = new __Parameter(period);
                
        this.next = new __Action<number>(this, __Origin.logical, period);
        this.start = new __InPort<boolean>(this);
        this.value = new __OutPort<number>(this);
        this.end = new __OutPort<boolean>(this);
                
                
        this.addReaction(
            new __Triggers(this.start),
            new __Args(this.start, this.schedulable(this.next), this.totalNumber, this.period),
            function (this, __start: Read<boolean>, __next: Sched<number>, __totalNumber: __Parameter<number>, __period: __Parameter<TimeValue>) {
                // =============== START react prologue
                const util = this.util;
                let start = __start.get();
                let next = __next.get();
                let actions = {next: __next};
                let totalNumber = __totalNumber.get();
                let period = __period.get();
                // =============== END react prologue
                try {
                    actions.next.schedule(0, 2);
                } finally {
                    // =============== START react epilogue
                            
                    // =============== END react epilogue
                }
            }
        );
        
        this.addReaction(
            new __Triggers(this.next),
            new __Args(this.schedulable(this.next), this.writable(this.value), this.writable(this.end), this.totalNumber, this.period),
            function (this, __next: Sched<number>, __value: ReadWrite<number>, __end: ReadWrite<boolean>, __totalNumber: __Parameter<number>, __period: __Parameter<TimeValue>) {
                // =============== START react prologue
                const util = this.util;
                let next = __next.get();
                let value = __value.get();
                let end = __end.get();
                let actions = {next: __next};
                let totalNumber = __totalNumber.get();
                let period = __period.get();
                // =============== END react prologue
                try {
                    const n: number = next as number;
                    
                    if (n <= totalNumber) {
                        actions.next.schedule(0, n+1);
                        value = n;
                    } else{
                        end = true;
                    }
                    
                } finally {
                    // =============== START react epilogue
                    if (value !== undefined) {
                        __value.set(value);
                    }
                    if (end !== undefined) {
                        __end.set(end);
                    }            
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class Ramp
// =============== START reactor class BenchmarkRunner
// *********** From the preamble, verbatim:
function median(execTimes: Array<number>, size: number): number {
    if (size == 0) {
        return 0.0;
    }

    const middle = size / 2;

    if(size % 2 == 1){
        return execTimes[middle]
    } else {
        return (execTimes[middle-1] + execTimes[middle]) / 2;
    }
}
    

// *********** End of preamble.

export class BenchmarkRunner extends __Reactor {
            
            
    num_iterations: __Parameter<number>;
    count: __State<number>;
    startTime: __State<TimeValue | undefined>;
    measuredTimes: __State<Array<number>>;
    nextIteration: __Action<boolean>;
    done: __Action<boolean>;
    finish: __InPort<boolean>;
    start: __OutPort<boolean>;
    constructor (
        parent: __Reactor, 
        num_iterations: number = 12
    ) {
        super(parent);
                
                
                
        this.num_iterations = new __Parameter(num_iterations);
        this.count = new __State(0);
        this.startTime = new __State(undefined);
        this.measuredTimes = new __State([]);
        this.nextIteration = new __Action<boolean>(this, __Origin.logical);
        this.done = new __Action<boolean>(this, __Origin.logical);
        this.finish = new __InPort<boolean>(this);
        this.start = new __OutPort<boolean>(this);
                
                
        this.addReaction(
            new __Triggers(this.startup),
            new __Args(this.schedulable(this.nextIteration), this.num_iterations, this.count, this.startTime, this.measuredTimes),
            function (this, __nextIteration: Sched<boolean>, __num_iterations: __Parameter<number>, __count: __State<number>, __startTime: __State<TimeValue | undefined>, __measuredTimes: __State<Array<number>>) {
                // =============== START react prologue
                const util = this.util;
                let nextIteration = __nextIteration.get();
                let actions = {nextIteration: __nextIteration};
                let num_iterations = __num_iterations.get();
                let count = __count.get();
                let startTime = __startTime.get();
                let measuredTimes = __measuredTimes.get();
                // =============== END react prologue
                try {
                    measuredTimes.length = num_iterations;
                    actions.nextIteration.schedule(0, true);
                    
                    console.log("Benchmark will run " + num_iterations + " times \n");
                    console.log("System information:")
                    console.log(`Platform: ${process.platform} \n`)
                } finally {
                    // =============== START react epilogue
                    if (count !== undefined) {
                        __count.set(count);
                    }
                    if (startTime !== undefined) {
                        __startTime.set(startTime);
                    }
                    if (measuredTimes !== undefined) {
                        __measuredTimes.set(measuredTimes);
                    }            
                    // =============== END react epilogue
                }
            }
        );
        
        this.addReaction(
            new __Triggers(this.nextIteration),
            new __Args(this.nextIteration, this.writable(this.start), this.schedulable(this.done), this.num_iterations, this.count, this.startTime, this.measuredTimes),
            function (this, __nextIteration: Read<boolean>, __start: ReadWrite<boolean>, __done: Sched<boolean>, __num_iterations: __Parameter<number>, __count: __State<number>, __startTime: __State<TimeValue | undefined>, __measuredTimes: __State<Array<number>>) {
                // =============== START react prologue
                const util = this.util;
                let nextIteration = __nextIteration.get();
                let start = __start.get();
                let done = __done.get();
                let actions = {done: __done};
                let num_iterations = __num_iterations.get();
                let count = __count.get();
                let startTime = __startTime.get();
                let measuredTimes = __measuredTimes.get();
                // =============== END react prologue
                try {
                    if (count < num_iterations) { 
                        startTime = util.getCurrentPhysicalTime();
                        start = true;
                    } else {
                        actions.done.schedule(0, true);
                    }
                } finally {
                    // =============== START react epilogue
                    if (start !== undefined) {
                        __start.set(start);
                    }
                    if (count !== undefined) {
                        __count.set(count);
                    }
                    if (startTime !== undefined) {
                        __startTime.set(startTime);
                    }
                    if (measuredTimes !== undefined) {
                        __measuredTimes.set(measuredTimes);
                    }            
                    // =============== END react epilogue
                }
            }
        );
        
        this.addReaction(
            new __Triggers(this.finish),
            new __Args(this.finish, this.schedulable(this.nextIteration), this.num_iterations, this.count, this.startTime, this.measuredTimes),
            function (this, __finish: Read<boolean>, __nextIteration: Sched<boolean>, __num_iterations: __Parameter<number>, __count: __State<number>, __startTime: __State<TimeValue | undefined>, __measuredTimes: __State<Array<number>>) {
                // =============== START react prologue
                const util = this.util;
                let finish = __finish.get();
                let nextIteration = __nextIteration.get();
                let actions = {nextIteration: __nextIteration};
                let num_iterations = __num_iterations.get();
                let count = __count.get();
                let startTime = __startTime.get();
                let measuredTimes = __measuredTimes.get();
                // =============== END react prologue
                try {
                    const duration = util.getCurrentPhysicalTime().subtract(startTime as TimeValue);
                    measuredTimes[count] = duration.toMilliseconds();
                    ++count;
                    
                    console.log("Iteration "+ count + " - " + duration.toMilliseconds() + " ms\n");
                    
                    actions.nextIteration.schedule(0, true);
                    
                } finally {
                    // =============== START react epilogue
                    if (count !== undefined) {
                        __count.set(count);
                    }
                    if (startTime !== undefined) {
                        __startTime.set(startTime);
                    }
                    if (measuredTimes !== undefined) {
                        __measuredTimes.set(measuredTimes);
                    }            
                    // =============== END react epilogue
                }
            }
        );
        
        this.addReaction(
            new __Triggers(this.done),
            new __Args(this.done, this.num_iterations, this.count, this.startTime, this.measuredTimes),
            function (this, __done: Read<boolean>, __num_iterations: __Parameter<number>, __count: __State<number>, __startTime: __State<TimeValue | undefined>, __measuredTimes: __State<Array<number>>) {
                // =============== START react prologue
                const util = this.util;
                let done = __done.get();
                let num_iterations = __num_iterations.get();
                let count = __count.get();
                let startTime = __startTime.get();
                let measuredTimes = __measuredTimes.get();
                // =============== END react prologue
                try {
                    measuredTimes.sort()
                    
                    console.log("Execution - Summary:\n");
                    console.log("Best Time:\t " + measuredTimes[0] + " msec\n");
                    console.log("Worst Time:\t " + measuredTimes[num_iterations - 1] + " msec\n");
                    console.log("Median Time:\t " + median(measuredTimes, num_iterations) + " msec\n");
                    
                    util.requestStop();
                } finally {
                    // =============== START react epilogue
                    if (count !== undefined) {
                        __count.set(count);
                    }
                    if (startTime !== undefined) {
                        __startTime.set(startTime);
                    }
                    if (measuredTimes !== undefined) {
                        __measuredTimes.set(measuredTimes);
                    }            
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class BenchmarkRunner
// =============== START reactor class Sieve


class Sieve extends __App {
    runner: BenchmarkRunner
    source: Ramp
    filter: Filter
            
    numIterations: __Parameter<number>;
    totalNumber: __Parameter<number>;
    primeStart: __Parameter<number>;
    primeNumber: __Parameter<number>;
    period: __Parameter<TimeValue>;
            
            
            
    constructor (
        timeout: TimeValue | undefined = undefined, 
        keepAlive: boolean = false, 
        fast: boolean = false, 
        federationID: string = 'Unidentified Federation', 
        numIterations: number = 12, 
        totalNumber: number = 1000, 
        primeStart: number = 2, 
        primeNumber: number = 100, 
        period: TimeValue = TimeValue.nsec(1), 
        success?: () => void, 
        fail?: () => void
    ) {
        super(timeout, keepAlive, fast, success, fail);
                
        this.runner = new BenchmarkRunner(this, numIterations)
        this.source = new Ramp(this, totalNumber, period)
        this.filter = new Filter(this, primeStart, primeNumber)
                
        this.numIterations = new __Parameter(numIterations);
        this.totalNumber = new __Parameter(totalNumber);
        this.primeStart = new __Parameter(primeStart);
        this.primeNumber = new __Parameter(primeNumber);
        this.period = new __Parameter(period);
                
                
                
        this._connect(this.runner.start, this.source.start);
        this._connect(this.source.value, this.filter.inp);
        this._connect(this.source.end, this.runner.finish);
                
        this.addReaction(
            new __Triggers(this.startup),
            new __Args(this.numIterations, this.totalNumber, this.primeStart, this.primeNumber, this.period),
            function (this, __numIterations: __Parameter<number>, __totalNumber: __Parameter<number>, __primeStart: __Parameter<number>, __primeNumber: __Parameter<number>, __period: __Parameter<TimeValue>) {
                // =============== START react prologue
                const util = this.util;
                let numIterations = __numIterations.get();
                let totalNumber = __totalNumber.get();
                let primeStart = __primeStart.get();
                let primeNumber = __primeNumber.get();
                let period = __period.get();
                // =============== END react prologue
                try {
                    console.log("Start Sieve of Eratosthenes LF Benchmark!");
                } finally {
                    // =============== START react epilogue
                            
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class Sieve
// ************* Instance Sieve of class Sieve
let __app;
if (!__noStart) {
    __app = new Sieve(__timeout, __keepAlive, __fast, __federationID, __CLnumIterations, __CLtotalNumber, __CLprimeStart, __CLprimeNumber, __CLperiod);
}
// ************* Starting Runtime for Sieve + of class Sieve.
if (!__noStart && __app) {
    __app._start();
}

